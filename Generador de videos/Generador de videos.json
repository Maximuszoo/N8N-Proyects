{
  "name": "Generador de videos",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.text }}",
        "options": {
          "systemMessage": "=Eres un asistente que convierte un guion con tiempos de narración en diapositivas para una presentación.\n\nCONTEXTO IMPORTANTE:\n- Estás procesando FRAGMENTOS de un audio continuo más largo (podcast/conferencia).\n- NO asumas que es el inicio o final del audio - trata cada fragmento como parte de un flujo continuo.\n- Enfócate únicamente en el contenido temático sin añadir fórmulas de cortesía artificiales.\n\nINSTRUCCIONES TÉCNICAS:\n- Vas a recibir un fragmento de guion que puede abarcar varios minutos de narración.\n- Debes crear UN SOLO ARRAY JSON continuo (no múltiples arrays separados).\n- Cada diapositiva debe tener un título claro y de 3 a 5 puntos clave.\n- Cada punto debe ser máximo 3 palabras (ideal: 1-2 palabras conceptuales).\n- Los tiempos deben ser SECUENCIALES y SIN GAPS ni SUPERPOSICIONES.\n- Usa SIEMPRE formato JSON válido.\n- No incluyas texto explicativo fuera del JSON.\n\nREGLAS DE TIEMPO OBLIGATORIAS:\n1. NO dejar gaps de tiempo sin slides (cada fin debe conectar con el inicio siguiente)\n2. NO superponer tiempos (cada fin debe ser igual al inicio siguiente) \n3. NO duplicar rangos de tiempo\n4. Crear timeline continuo desde el primer segundo hasta el último del fragmento\n\nFORMATO DE SALIDA EXACTO:\n[\n  {\n    \"inicio\": \"MM:SS\",\n    \"fin\": \"MM:SS\", \n    \"titulo\": \"Concepto Principal\",\n    \"puntos\": [\n      \"Idea Central\",\n      \"Punto Clave\", \n      \"Conclusión\"\n    ]\n  },\n  {\n    \"inicio\": \"MM:SS\",\n    \"fin\": \"MM:SS\",\n    \"titulo\": \"Siguiente Concepto\", \n    \"puntos\": [\n      \"Nueva Idea\",\n      \"Desarrollo\",\n      \"Aplicación\"\n    ]\n  }\n]\n\nVERIFICACIÓN OBLIGATORIA:\n✓ ¿Es un solo array JSON válido?\n✓ ¿Los tiempos son secuenciales sin gaps?\n✓ ¿No hay superposiciones temporales?\n✓ ¿Cada punto es máximo 3 palabras?\n✓ ¿No agregué saludos/despedidas artificiales?\n\nPROHIBIDO:\n❌ Múltiples arrays separados\n❌ Gaps temporales entre slides\n❌ Superposiciones de tiempo\n❌ Puntos de más de 3 palabras\n❌ Saludos/despedidas no presentes en el original\n❌ Texto explicativo fuera del JSON\n❌ Asumir inicio/final del contenido completo"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        592,
        384
      ],
      "id": "144ffec0-e03c-42c9-b4aa-e670441e28f6",
      "name": "AI Agent",
      "alwaysOutputData": false,
      "executeOnce": false,
      "retryOnFail": false
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "numCtx": 10240
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        512,
        688
      ],
      "id": "87ae39db-8e75-4d6f-9627-abb5e78f1d47",
      "name": "Ollama Chat Model",
      "credentials": {
        "ollamaApi": {
          "id": "7pkBbOXaK78v4TXY",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.text }}",
        "contextWindowLength": 2
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        736,
        688
      ],
      "id": "4844fce2-1482-4505-abcf-d1b121d140b8",
      "name": "Simple Memory"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -576,
        368
      ],
      "id": "72a39755-d9d4-410d-b23a-73be8d3739c2",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "fileSelector": "/your/input/path/script.txt",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        -368,
        368
      ],
      "id": "2595c986-6d8e-4134-824f-9b9c61f1f66c",
      "name": "Read/Write Files from Disk"
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -160,
        368
      ],
      "id": "ca8c544e-c945-4a4c-a165-9873c0e532ab",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "const fullText = $input.first().json.data;\nconst maxLength = 4000;\nconst overlapLength = 0; // Solapamiento entre chunks para mantener contexto\n\n/**\n * ============================================================================\n * DIVISOR INTELIGENTE DE PDF PARA PROCESAMIENTO CON LLM\n * ============================================================================\n * \n * PROPÓSITO:\n * Este script divide documentos PDF largos en fragmentos (chunks) inteligentes\n * para ser procesados por modelos de lenguaje con contexto limitado como Llama 3.1.\n * A diferencia de una división simple por caracteres, este código preserva la\n * estructura semántica del texto y mantiene contexto entre fragmentos.\n * \n * PROBLEMA QUE RESUELVE:\n * - Los LLMs locales tienen límites de contexto (tokens/caracteres)\n * - La división simple corta palabras, oraciones y párrafos arbitrariamente\n * - Se pierde coherencia y contexto entre fragmentos\n * - El modelo no puede responder correctamente con información incompleta\n * \n * ESTRATEGIA DE DIVISIÓN:\n * 1. JERARQUÍA DE CORTES (de mayor a menor prioridad):\n *    - Saltos de párrafo (doble \\n): Mantiene párrafos completos\n *    - Saltos de línea simple (\\n): Respeta estructura de líneas\n *    - Final de oraciones (. ! ?): Evita oraciones incompletas\n *    - Puntuación menor (, ; :): Puntos naturales de pausa\n *    - Espacios entre palabras: Evita cortar palabras\n *    - Posición exacta: Solo si no hay alternativa\n * \n * 2. SOLAPAMIENTO DE CONTEXTO:\n *    - Incluye ~200 caracteres finales del chunk anterior\n *    - Añade preview del siguiente chunk\n *    - Permite al LLM mantener continuidad narrativa\n * \n * 3. METADATOS ENRIQUECIDOS:\n *    Cada fragmento incluye:\n *    - Posición en el documento (index/total)\n *    - Ubicación de caracteres originales\n *    - Estadísticas (palabras, líneas)\n *    - Vista previa del contenido\n *    - Indicadores de continuidad\n * \n * FLUJO DE PROCESAMIENTO:\n * 1. Recibe texto completo del PDF\n * 2. Divide en chunks respetando estructura semántica\n * 3. Añade solapamiento para mantener contexto\n * 4. Agrega metadatos útiles para el LLM\n * 5. Retorna array de fragmentos listos para procesar\n * \n * CONFIGURACIÓN:\n * - maxLength: 8000 caracteres (ajustable según tu modelo)\n * - overlapLength: 200 caracteres de contexto compartido\n * - searchRange: 500 caracteres de flexibilidad para encontrar cortes\n * \n * USO POSTERIOR:\n * Los fragmentos resultantes se envían secuencialmente al LLM,\n * y las respuestas se concatenan para formar la respuesta completa.\n * \n * VENTAJAS VS DIVISIÓN SIMPLE:\n * ✓ Preserva significado y coherencia\n * ✓ Mantiene contexto entre fragmentos\n * ✓ Respeta estructura del documento\n * ✓ Mejora calidad de respuestas del LLM\n * ✓ Evita cortes en medio de ideas importantes\n * \n * ============================================================================\n */\n\n/**\n * Encuentra el mejor punto de corte cerca del límite máximo\n * Prioridad: párrafo > oración > palabra\n */\nfunction findBestSplitPoint(text, targetIndex) {\n  // Buscar hacia atrás desde el punto objetivo\n  const searchRange = 500; // Rango de búsqueda flexible\n  const startSearch = Math.max(0, targetIndex - searchRange);\n  const endSearch = Math.min(text.length, targetIndex + 100);\n  const searchText = text.slice(startSearch, endSearch);\n  \n  // 1. Intentar cortar en un salto de párrafo (doble salto de línea)\n  const paragraphBreak = searchText.lastIndexOf('\\n\\n');\n  if (paragraphBreak !== -1) {\n    return startSearch + paragraphBreak + 2;\n  }\n  \n  // 2. Intentar cortar en un salto de línea simple\n  const lineBreak = searchText.lastIndexOf('\\n');\n  if (lineBreak !== -1) {\n    return startSearch + lineBreak + 1;\n  }\n  \n  // 3. Intentar cortar en el final de una oración\n  const sentenceEndings = ['. ', '! ', '? ', '.\\n', '!\\n', '?\\n'];\n  let bestSentenceEnd = -1;\n  let bestSentencePos = -1;\n  \n  for (const ending of sentenceEndings) {\n    const pos = searchText.lastIndexOf(ending);\n    if (pos > bestSentencePos) {\n      bestSentencePos = pos;\n      bestSentenceEnd = startSearch + pos + ending.length;\n    }\n  }\n  \n  if (bestSentenceEnd !== -1) {\n    return bestSentenceEnd;\n  }\n  \n  // 4. Intentar cortar en una coma o punto y coma\n  const punctuation = [', ', '; ', ': '];\n  let bestPunctuationPos = -1;\n  let bestPunctuationEnd = -1;\n  \n  for (const punct of punctuation) {\n    const pos = searchText.lastIndexOf(punct);\n    if (pos > bestPunctuationPos) {\n      bestPunctuationPos = pos;\n      bestPunctuationEnd = startSearch + pos + punct.length;\n    }\n  }\n  \n  if (bestPunctuationEnd !== -1) {\n    return bestPunctuationEnd;\n  }\n  \n  // 5. Como último recurso, cortar en un espacio\n  const spacePos = searchText.lastIndexOf(' ');\n  if (spacePos !== -1) {\n    return startSearch + spacePos + 1;\n  }\n  \n  // 6. Si no hay espacios, cortar en el punto objetivo\n  return targetIndex;\n}\n\n/**\n * Añade metadatos útiles a cada chunk\n */\nfunction createChunkMetadata(text, index, totalChunks, startChar, endChar) {\n  // Extraer las primeras palabras como preview\n  const preview = text.slice(0, 100).replace(/\\n/g, ' ').trim();\n  \n  // Contar estadísticas básicas\n  const wordCount = text.split(/\\s+/).filter(word => word.length > 0).length;\n  const lineCount = text.split('\\n').length;\n  \n  return {\n    index: index,\n    totalChunks: totalChunks,\n    startChar: startChar,\n    endChar: endChar,\n    wordCount: wordCount,\n    lineCount: lineCount,\n    preview: preview + (text.length > 100 ? '...' : ''),\n    hasOverlapWithNext: index < totalChunks - 1\n  };\n}\n\n/**\n * Divide el texto en chunks inteligentes\n */\nfunction splitTextIntelligently(text, maxChunkLength, overlap) {\n  const chunks = [];\n  let currentPosition = 0;\n  \n  // Primera pasada: dividir sin solapamiento\n  const rawChunks = [];\n  while (currentPosition < text.length) {\n    let endPosition;\n    \n    if (currentPosition + maxChunkLength >= text.length) {\n      // Último chunk\n      endPosition = text.length;\n    } else {\n      // Buscar el mejor punto de corte\n      endPosition = findBestSplitPoint(text, currentPosition + maxChunkLength);\n    }\n    \n    rawChunks.push({\n      start: currentPosition,\n      end: endPosition,\n      text: text.slice(currentPosition, endPosition)\n    });\n    \n    currentPosition = endPosition;\n  }\n  \n  // Segunda pasada: añadir solapamiento y crear chunks finales\n  for (let i = 0; i < rawChunks.length; i++) {\n    let chunkText = rawChunks[i].text;\n    let startPos = rawChunks[i].start;\n    let endPos = rawChunks[i].end;\n    \n    // Añadir contexto del chunk anterior (excepto en el primero)\n    if (i > 0 && overlap > 0) {\n      const overlapStart = Math.max(\n        rawChunks[i-1].end - overlap,\n        rawChunks[i-1].start\n      );\n      const overlapText = text.slice(overlapStart, rawChunks[i-1].end);\n      \n      // Añadir marcador de contexto previo\n      if (overlapText.trim()) {\n        chunkText = `[...contexto anterior: ${overlapText.trim().slice(-overlap)}]\\n\\n${chunkText}`;\n      }\n    }\n    \n    // Añadir preview del siguiente chunk (excepto en el último)\n    if (i < rawChunks.length - 1 && overlap > 0) {\n      const nextPreview = rawChunks[i + 1].text.slice(0, Math.min(overlap, 100));\n      if (nextPreview.trim()) {\n        chunkText = `${chunkText}\\n\\n[...continúa: ${nextPreview.trim()}...]`;\n      }\n    }\n    \n    const metadata = createChunkMetadata(\n      chunkText,\n      i,\n      rawChunks.length,\n      startPos,\n      endPos\n    );\n    \n    chunks.push({\n      json: {\n        text: chunkText.trim(),\n        ...metadata\n      }\n    });\n  }\n  \n  return chunks;\n}\n\n// Validación de entrada\nif (!fullText || typeof fullText !== 'string') {\n  return [{\n    json: {\n      error: 'No se proporcionó texto válido para procesar',\n      text: '',\n      index: 0,\n      totalChunks: 0\n    }\n  }];\n}\n\n// Procesar el texto\nconst parts = splitTextIntelligently(fullText, maxLength, overlapLength);\n\n// Log de información útil\nconsole.log(`Texto dividido en ${parts.length} partes:`);\nparts.forEach(part => {\n  console.log(`  - Parte ${part.json.index + 1}: ${part.json.wordCount} palabras, ${part.json.lineCount} líneas`);\n});\n\nreturn parts;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        368
      ],
      "id": "f5c9b6b8-8007-4a01-90ea-974890b362e7",
      "name": "Code"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        256,
        368
      ],
      "id": "5367ef13-f774-4025-898a-353418d7f750",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "content": "## Acá poner la ruta en  nuestro pc, del archivo de la trascripción del audio.",
        "height": 496,
        "width": 208,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -416,
        96
      ],
      "typeVersion": 1,
      "id": "c9a0d066-108f-489b-9d80-d7433643d8ee",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## En está parte podemos cambiar el tamaño de división del texto.\nMientras más grande más info se pierde, pero si es muy chico el contexto queda medio mal.",
        "height": 592,
        "width": 214,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "cc0e1a11-eb02-46f5-a0fd-866e9f3715e4",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "command": "=printf '%s\\n\\n' '{{ $json.output }}' >> /your/output/path/slides_script.txt"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1232,
        384
      ],
      "id": "1c01ee6e-c8f1-4702-872c-62bf6ab0652e",
      "name": "Archivo md",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "/**\n * ============================================================================\n * REMOVEDOR DE TAGS <think> DE RESPUESTAS DEEPSEEK PARA N8N\n * ============================================================================\n * \n * PROPÓSITO:\n * Este script elimina los bloques de pensamiento (<think>...</think>) que\n * DeepSeek incluye en sus respuestas cuando usa el modo de razonamiento.\n * Extrae solo el contenido útil de la respuesta, descartando el proceso\n * de pensamiento interno del modelo.\n * \n * PROBLEMA QUE RESUELVE:\n * - DeepSeek puede incluir largos bloques de pensamiento que no son necesarios\n * - Estos bloques ocupan espacio y dificultan la lectura de la respuesta real\n * - No todos los modelos incluyen estos tags, por lo que el código debe ser flexible\n * \n * FUNCIONAMIENTO:\n * 1. Recibe la respuesta completa del modelo\n * 2. Detecta si existen tags <think>\n * 3. Si existen, los elimina junto con todo su contenido\n * 4. Retorna solo el contenido útil limpio\n * 5. Si no hay tags <think>, retorna el texto original sin modificar\n * \n * CASOS DE USO:\n * - Funciona con respuestas que incluyen <think>...</think>\n * - Funciona con respuestas sin estos tags (otros modelos)\n * - Maneja múltiples bloques <think> si existieran\n * - Preserva todo el formato del contenido útil (markdown, LaTeX, etc.)\n * \n * ============================================================================\n */\n\n// Obtener el texto de salida del modelo\nconst responseText = $input.first().json.output;\n\n// Validación de entrada\nif (!responseText || typeof responseText !== 'string') {\n  // Si no hay texto o no es string, devolver como está\n  return [{\n    json: {\n      output: responseText || '',\n      hadThinkTag: false,\n      originalLength: 0,\n      cleanedLength: 0\n    }\n  }];\n}\n\n/**\n * Función para remover todos los bloques <think>...</think>\n * Usa regex con modo 's' para que el punto coincida con saltos de línea\n */\nfunction removeThinkBlocks(text) {\n  // Patrón regex que captura <think> hasta </think> incluyendo saltos de línea\n  // El flag 's' permite que . coincida con \\n\n  // El flag 'gi' hace la búsqueda global e insensible a mayúsculas\n  const thinkPattern = /<think>[\\s\\S]*?<\\/think>/gi;\n  \n  // Verificar si existe el patrón\n  const hasThinkTag = thinkPattern.test(text);\n  \n  // Reiniciar el índice del regex después del test\n  thinkPattern.lastIndex = 0;\n  \n  // Remover todos los bloques <think>\n  let cleanedText = text.replace(thinkPattern, '');\n  \n  // Limpiar espacios en blanco excesivos que puedan quedar\n  // Remover líneas vacías múltiples consecutivas\n  cleanedText = cleanedText.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n  \n  // Eliminar espacios en blanco al inicio y final\n  cleanedText = cleanedText.trim();\n  \n  return {\n    cleaned: cleanedText,\n    hadThinkTag: hasThinkTag\n  };\n}\n\n// Procesar el texto\nconst result = removeThinkBlocks(responseText);\n\n// Preparar estadísticas útiles para debugging\nconst stats = {\n  originalLength: responseText.length,\n  cleanedLength: result.cleaned.length,\n  charactersRemoved: responseText.length - result.cleaned.length,\n  hadThinkTag: result.hadThinkTag\n};\n\n// Log para debugging (opcional - puedes comentarlo en producción)\nif (result.hadThinkTag) {\n  console.log(`Removidos ${stats.charactersRemoved} caracteres de bloques <think>`);\n} else {\n  console.log('No se encontraron bloques <think> en la respuesta');\n}\n\n// Retornar el texto limpio con metadatos\nreturn [{\n  json: {\n    output: result.cleaned,\n    ...stats\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        944,
        384
      ],
      "id": "5808d6b0-3efb-4728-9b2d-f585733f8bad",
      "name": "Remueve Think"
    },
    {
      "parameters": {
        "content": "## Recordar cambiarle el nombre al Podcast a podcast.mp3 y que este en la ruta adecuada. \n# ¡Atención!",
        "height": 464
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        512,
        -144
      ],
      "typeVersion": 1,
      "id": "96ed16f6-13a8-483b-8ddf-ba43b4620378",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "command": "python3 \"/your/scripts/path/Vidazor/generate_video.py\" \"/your/output/path/slides_script.txt\" \"/your/input/path/audio.mp3\" \"/your/output/path/Video_$(date +%Y%m%d_%H%M%S).mp4\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        592,
        176
      ],
      "id": "20d8d2f3-816d-4021-bafb-5f97e0ec36b0",
      "name": "Vidazor"
    },
    {
      "parameters": {
        "command": "mv /your/output/path/slides_script.txt \"/your/output/path/slides_script_$(date +%Y%m%d_%H%M%S).txt\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        880,
        176
      ],
      "id": "217d38ae-a43c-4f1b-84f7-d4bf97762513",
      "name": "Renombrar TXT"
    },
    {
      "parameters": {
        "command": "mv /your/input/path/audio.mp3 \"/your/output/path/audio_procesado_$(date +%Y%m%d_%H%M%S).mp3\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1088,
        176
      ],
      "id": "4f3b77db-134c-4cc3-a97f-e62db22cd018",
      "name": "Renombrar MP3"
    }
  ],
  "pinData": {},
  "connections": {
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Remueve Think",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Read/Write Files from Disk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read/Write Files from Disk": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Vidazor",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Archivo md": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remueve Think": {
      "main": [
        [
          {
            "node": "Archivo md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vidazor": {
      "main": [
        [
          {
            "node": "Renombrar TXT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Renombrar TXT": {
      "main": [
        [
          {
            "node": "Renombrar MP3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "4f837bb9-f10f-4b23-a8fb-3f875c7cdcd7",
  "meta": {
    "instanceId": "1202ebb5c5bf98f36da91d0bc10557c87c005af857f777d70650a3bb96d64a62"
  },
  "id": "Bp7LS7WAmmIR4cPq",
  "tags": []
}